#!/usr/bin/env python3.9
import os
import sys
import enum
import time
import json
import requests
import logging
import logging.config
from datetime import timedelta, datetime

from sqlalchemy.exc import OperationalError
from sqlalchemy.orm import sessionmaker
from sqlalchemy import create_engine

from finbot.core.utils import configure_logging
from finbot.core import environment


configure_logging()


FINBOT_ENV = environment.get()


class ExitCode(enum.Enum):
    Ok = 0
    Timeout = 1
    Error = 2


class Error(RuntimeError):
    pass


class ClientChecker(object):
    def __init__(self, endpoint: str):
        self._endpoint = endpoint

    def __call__(self) -> bool:
        try:
            response = requests.get(f"{self._endpoint}/healthy")
            if not response:
                return False
            return json.loads(response.content)["healthy"]
        except requests.RequestException:
            return False


class WebsiteChecker(object):
    def __init__(self, url: str):
        self._url = url

    def __call__(self) -> bool:
        try:
            requests.get(f"{self._url}")
            return True
        except requests.RequestException:
            return False


class DbChecker(object):
    def __init__(self, db_url):
        engine = create_engine(db_url)
        self._session = sessionmaker(bind=engine)()

    def __call__(self) -> bool:
        try:
            self._session.execute("SELECT 1")
            return True
        except OperationalError:
            return False


def get_checker(dep_name: str):
    if dep_name == "db":
        logging.info(f"will wait on 'db': {FINBOT_ENV.database_url}")
        return DbChecker(FINBOT_ENV.database_url)
    if dep_name == "api":
        logging.info(f"will wait on 'api': {FINBOT_ENV.appwsrv_endpoint}")
        return ClientChecker(FINBOT_ENV.appwsrv_endpoint)
    if dep_name == "finbot":
        logging.info(f"will wait on 'finbot': {FINBOT_ENV.finbotwsrv_endpoint}")
        return ClientChecker(FINBOT_ENV.finbotwsrv_endpoint)
    if dep_name == "hist":
        logging.info(f"will wait on 'hist': {FINBOT_ENV.histwsrv_endpoint}")
        return ClientChecker(FINBOT_ENV.histwsrv_endpoint)
    if dep_name == "snap":
        logging.info(f"will wait on 'snap': {FINBOT_ENV.snapwsrv_endpoint}")
        return ClientChecker(FINBOT_ENV.snapwsrv_endpoint)
    if dep_name == "webapp":
        logging.info(f"will wait on 'webapp': {FINBOT_ENV.webapp_endpoint}")
        return WebsiteChecker(FINBOT_ENV.webapp_endpoint)
    raise Error(f"Unknown dependency: {dep_name}")


def main_impl() -> ExitCode:
    raw_deps = os.environ.get("FINBOT_WAIT_DEPS")
    raw_timeout = os.environ.get("FINBOT_WAIT_TIMEOUT")
    timeout = raw_timeout if not raw_timeout else timedelta(seconds=float(raw_timeout))
    if not timeout:
        logging.warning("no timeout specified")
    start_time = datetime.now()
    if not raw_deps:
        logging.warning("No dependencies to wait on (FINBOT_WAIT_DEPS not defined)")
        return ExitCode.Ok
    deps = list(set(raw_deps.split(",")))
    resolved = set()
    checkers = {dep: get_checker(dep) for dep in deps}
    wait_interval = int(os.environ.get("FINBOT_WAIT_INTERVAL", 3))
    logging.info(f"waiting on the following dependencies: {', '.join(checkers.keys())}")
    while True:
        for dep, checker in checkers.items():
            if dep not in resolved:
                if checker():
                    resolved.add(dep)
                    logging.info(f"dependency {dep} is now available")
                else:
                    logging.info(f"dependency {dep} is not yet available")
        if len(resolved) == len(checkers):
            break
        if timeout and datetime.now() - start_time > timeout:
            logging.warning(f"still waiting for dependencies after timeout ({timeout.total_seconds()}s), aborting")
            return ExitCode.Timeout
        time.sleep(wait_interval)
    logging.info(f"all dependencies available: {', '.join(deps)}")
    return ExitCode.Ok


def main() -> ExitCode:
    try:
        return main_impl()
    except Exception as e:
        logging.error(str(e))
        return ExitCode.Error


if __name__ == "__main__":
    sys.exit(main().value)
