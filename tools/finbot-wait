#!/usr/bin/env python3.9
from finbot.clients.worker import WorkerClient
from finbot.core.logging import configure_logging
from finbot.core import environment

from sqlalchemy.exc import OperationalError
from sqlalchemy.orm import sessionmaker
from sqlalchemy import create_engine

import pika
import pika.exceptions

from datetime import timedelta, datetime
import os
import sys
import socket
import enum
import time
import json
import requests
import logging
import logging.config


configure_logging()


FINBOT_ENV = environment.get()


class ExitCode(enum.Enum):
    Ok = 0
    Timeout = 1
    Error = 2


class Error(RuntimeError):
    pass


class ClientChecker(object):
    def __init__(self, endpoint: str):
        self._endpoint = endpoint

    def __call__(self) -> bool:
        try:
            response = requests.get(f"{self._endpoint}/healthy")
            if not response:
                return False
            return json.loads(response.content)["healthy"]
        except requests.RequestException:
            return False


class WebsiteChecker(object):
    def __init__(self, url: str):
        self._url = url

    def __call__(self) -> bool:
        try:
            requests.get(f"{self._url}")
            return True
        except requests.RequestException:
            return False


class DbChecker(object):
    def __init__(self, db_url: str):
        engine = create_engine(db_url)
        self._session = sessionmaker(bind=engine)()

    def __call__(self) -> bool:
        try:
            self._session.execute("SELECT 1")
            return True
        except OperationalError:
            return False


class RabbitMQChecker(object):
    def __init__(self, rmq_url: str):
        self._url = rmq_url

    def __call__(self) -> bool:
        try:
            connection = pika.BlockingConnection(pika.URLParameters(self._url))
            connection.channel()
            return True
        except (socket.gaierror, pika.exceptions.AMQPError) as e:
            return False


class CeleryWorkerChecker(object):
    def __init__(self, client: WorkerClient):
        self._client = client

    def __call__(self) -> bool:
        try:
            self._client.get_healthy(timeout=1.0)
            return True
        except Exception as e:
            return False


def get_checker(dep_name: str):
    if dep_name == "db":
        logging.info(f"will wait on 'db': {FINBOT_ENV.database_url}")
        return DbChecker(FINBOT_ENV.database_url)
    if dep_name == "rmq":
        logging.info(f"will wait on 'rmq': {FINBOT_ENV.rmq_url}")
        return RabbitMQChecker(FINBOT_ENV.rmq_url)
    if dep_name == "worker":
        logging.info("will wait on 'worker'")
        return CeleryWorkerChecker(WorkerClient())
    if dep_name == "api":
        logging.info(f"will wait on 'api': {FINBOT_ENV.appwsrv_endpoint}")
        return ClientChecker(FINBOT_ENV.appwsrv_endpoint)
    if dep_name == "finbot":
        logging.info(f"will wait on 'finbot': {FINBOT_ENV.finbotwsrv_endpoint}")
        return ClientChecker(FINBOT_ENV.finbotwsrv_endpoint)
    if dep_name == "hist":
        logging.info(f"will wait on 'hist': {FINBOT_ENV.histwsrv_endpoint}")
        return ClientChecker(FINBOT_ENV.histwsrv_endpoint)
    if dep_name == "snap":
        logging.info(f"will wait on 'snap': {FINBOT_ENV.snapwsrv_endpoint}")
        return ClientChecker(FINBOT_ENV.snapwsrv_endpoint)
    if dep_name == "webapp":
        logging.info(f"will wait on 'webapp': {FINBOT_ENV.webapp_endpoint}")
        return WebsiteChecker(FINBOT_ENV.webapp_endpoint)
    raise Error(f"Unknown dependency: {dep_name}")


def main_impl() -> ExitCode:
    raw_deps = os.environ.get("FINBOT_WAIT_DEPS")
    raw_timeout = os.environ.get("FINBOT_WAIT_TIMEOUT")
    timeout = raw_timeout if not raw_timeout else timedelta(seconds=float(raw_timeout))
    if not timeout:
        logging.warning("no timeout specified")
    start_time = datetime.now()
    if not raw_deps:
        logging.warning("No dependencies to wait on (FINBOT_WAIT_DEPS not defined)")
        return ExitCode.Ok
    deps = list(set(raw_deps.split(",")))
    resolved = set()
    checkers = {dep: get_checker(dep) for dep in deps}
    wait_interval = int(os.environ.get("FINBOT_WAIT_INTERVAL", 3))
    logging.info(f"waiting on the following dependencies: {', '.join(checkers.keys())}")
    while True:
        for dep, checker in checkers.items():
            if dep not in resolved:
                try:
                    if checker():
                        resolved.add(dep)
                        logging.info(f"dependency {dep} is now available")
                    else:
                        logging.info(f"dependency {dep} is not yet available")
                except Exception as e:
                    logging.error(f"fatal error while checking dependency {dep}: {e}")
                    raise
        if len(resolved) == len(checkers):
            break
        if timeout and datetime.now() - start_time > timeout:
            logging.warning(f"still waiting for dependencies after timeout ({timeout.total_seconds()}s), aborting")
            return ExitCode.Timeout
        time.sleep(wait_interval)
    logging.info(f"all dependencies available: {', '.join(deps)}")
    return ExitCode.Ok


def main() -> ExitCode:
    try:
        return main_impl()
    except Exception as e:
        logging.error(f"leaving early because of uncaught error: {e}")
        return ExitCode.Error


if __name__ == "__main__":
    sys.exit(main().value)
